# This Python file uses the following encoding: utf-8
import numpy as np
import os
import sys
import subprocess
import tempfile
import rpc_model


# add the bin folder to system path
current_dir = os.path.dirname(os.path.abspath(__file__))
parent_dir = os.path.dirname(current_dir)
bin_dir = os.path.join(parent_dir, 'bin')
os.environ['PATH'] = bin_dir + os.pathsep + os.environ['PATH']

# global variable
# list of intermediary files generated by the script
garbage = list()

def tmpfile(ext=''):
    """
    Creates a temporary file in the /tmp directory.

    Args:
        ext: desired file extension

    Returns:
        absolute path to the created file

    The path of the created file is added to the garbage list to allow cleaning
    at the end of the pipeline.
    """
    fd, out = tempfile.mkstemp(suffix = ext, prefix = 's2p_', dir = '/tmp')
    garbage.append(out)
    os.close(fd)           # http://www.logilab.org/blogentry/17873
    return out


def run(cmd):
    """
    Runs a shell command, and print it before running.
    """
    print cmd
    subprocess.call(cmd, shell=True)


def shellquote(s):
    return "'" + s.replace("'", "'\\''") + "'"


def matrix_write(filename, H):
    """
    Writes a 3x3 matrix in a file using the matlab format.

    Args:
        filename: path of the file where to write the matrix
        H: 3x3 array
    """
    f = open(filename, 'w')
    f.write('[ %.20f  %.20f  %.20f ; ' % (H[0, 0], H[0, 1], H[0, 2]))
    f.write('  %.20f  %.20f  %.20f ; ' % (H[1, 0], H[1, 1], H[1, 2]))
    f.write('  %.20f  %.20f  %.20f ] ' % (H[2, 0], H[2, 1], H[2, 2]))
    f.close()


def matrix_read(fileName, rows=None, cols=None):
    return matrix_read_from_string(open(fileName).read(), rows, cols)


def matrix_read_from_string(line, rows=None, cols=None):
    x0 = []
    line = line.replace('[',' ')
    line = line.replace(']',' ')
    line = line.replace(',',' ')
    line = line.replace(';',' ')
    da = line.split()
    x0.append(map(float,da))
    #
    if(cols == None):
       x0 = np.array(x0)
    else:
       x0 = np.array(x0).reshape(rows, cols)
    #
    return(x0)


def matrix_translation(tx, ty):
    T = np.eye(3)
    T[0, 2] = tx;
    T[1, 2] = ty;
    return T


def image_size(im):
    out = tmpfile('.txt')
    run('imprintf "%%w %%h" %s > %s' % (shellquote(im), out));
    (nc, nr) = map(int, open(out).read().split())
    return (nc, nr)


def image_pix_dim(im):
    out = tmpfile('.txt')
    run('imprintf "%%c" %s > %s' % (shellquote(im), out));
    dim = open(out).readline().split()[0]
    return int(dim)


def image_crop(im, x, y, w, h, out=None):
    if (out == None):
        out = tmpfile('.tif')
    run('crop %s %s %d %d %d %d' % (im, out, x, y, w, h));
    return out


def image_fftconvolve(im, mtf):
    """
    returns the fourier convolution: F^{-1} ( F(im)  mtf )
    mtf and im must be the same size
    """
    out = tmpfile('.tif')
    run('fftconvolve %s %s %s' % (mtf, im, out))
    return out


def image_zeropadding_from_image_with_target_size(im, image_with_target_size):
    """
    zooms im by zero padding to the size of the image_with_target_size
    It works with the fft representation of im
    and just adds or remove frequencies from it
    No control of Gibbs artifacts
    """
    out = tmpfile('.tif')
    run('zoom_zeropadding %s %s %s' % (image_with_target_size, im, out))
    return out

def image_safe_zoom_fft(im, f):
    """
    zooms im by a factor: f∈[0,1] for zoom in, f∈[1 +inf] for zoom out
    It works with the fft representation of the symmetrized im thus it
    controls the Gibbs artifacts.
    In case of zoom out it filters the image before truncating the
    spectrum, for zoom in it performs a zero padding.
    Because of the discrete frequency representation the zero padding/
    truncation may yield a final zoom factor that differs from the
    desired one, particularly for small source or target images.
    """
    if f == 1:
        return im
    out = tmpfile('.tif')
    sz = image_size(im)
    # FFT doesn't play nice with infinite values, so we remove them
    run('zoom_2d %s %s %d %d' % (im, out, sz[0]/f, sz[1]/f))
    return out

def image_zoom_out_morpho(im, f):
    """
    Image zoom out by morphological operation (median).

    Args:
        im: path to the input image
        f: zoom out factor. It has to be a positive integer

    Returns:
        path to the output image
    """
    if (f != np.floor(f)):
        print 'image_zoom_out_morpho: zoom factor has to be integer'
        sys.exit()

    out = tmpfile('.tif')
    run('downsa e %d %s %s' % (f, im, out))
    return out


def image_apply_homography(out, im, H, w, h):
    """
    Applies an homography to an image.

    Args:
        out: path to the output image file
        im: path to the input image file
        H: numpy array containing the 3x3 homography matrix
        w, h: dimensions (width and height) of the output image

    The output image is defined on the domain [0, w] x [0, h]. Its pixels
    intensities are defined by out(x) = im(H^{-1}(x)). This function calls
    Pascal Monasse homography binary, refactored by Gabriele.
    """
    # write the matrix to a file
    Hf = tmpfile('.txt')
    matrix_write(Hf, H)
    # apply the homography
    out_png = tmpfile('.png')
    run("homography %s %s %s %s 0 %d %d" % (im, Hf, out_png, out, w, h))
    return


def median_filter(im, w, n):
    """
    Applies median filter.

    Args:
        im: path to the input image
        w: window size
        n: number of repetitions

    Returns:
        path to the filtered image
    """
    out = tmpfile('.tif')
    run('cp %s %s' % (im, out))
    for i in xrange(n):
        run('morphoop %s median %d %s' % (out, w, out))
    return out



def image_qauto(im):
    """
    Uniform requantization between min and max intensity.

    Args:
        im: path to input image

    Returns:
        path of requantized image, saved as png
    """
    out = tmpfile('.png')
    run('qauto %s %s 2> /dev/null' % (im, out))
    return out


def image_qeasy(im, black, white):
    """
    Uniform requantization between user-specified min and max levels.

    Args:
        im: path to input image
        black: lower threshold. Values lower or equal are mapped to 0
        white: upper threshold. Values greater or equal are mapped to 255

    Returns:
        path of requantized image, saved as png
    """
    out = tmpfile('.png')
    run('qeasy %d %d %s %s 2> /dev/null' % (black, white, im, out))
    return out


def rgbi_to_rgb(im):
    """
    Converts a 4-channel red, green, blue, infrared (rgbi) image to rgb.

    Args:
        im: path to the input image

    Returns:
        output rgb image
    """
    out = tmpfile('.tif')
    run('plambda %s "x[0] x[1] 0.9 * x[3] 0.1 * + x[2] join3" | iion - %s'%(im,
                                                                           out))
    return out


def image_sift_keypoints(im, keyfile='', max_nb=None):
    """
    Runs sift (the keypoints detection and description only, no matching).

    Args:
        im: path to the input image
        keyfile: path to the file where to write the list of sift descriptors
        max_nb: maximal number of keypoints. If more keypoints are detected,
            those at smallest scales are discarded

    Returns:
        path to the file containing the list of descriptors
    """
    if (keyfile == ''):
       keyfile = tmpfile('.txt')
    run("sift_keypoints %s %s" % (image_qauto(im), keyfile))

    # remove header from keypoint files
    tmp = tmpfile('.txt')
    run("awk \'{if (NR!=1) {print}}\' %s > %s" % (keyfile, tmp))
    run("cp %s %s" % (tmp, keyfile))

    # keep only the first max_nb points
    if max_nb:
        run("head -n %d %s > %s" % (max_nb, keyfile, tmp))
        run("cp %s %s" % (tmp, keyfile))
    return keyfile


def sift_keypoints_match(k1, k2, method, thresh):
    """
    Find matches among two lists of sift keypoints.

    Args:
        k1, k2: paths to text files containing the lists of sift descriptors
        method: flag (0 or 1) indicating wether to use absolute distance (0) or
            relative distance (1)
        thresh: threshold for distance between SIFT descriptors. These
            descriptors are 128-vectors, whose coefficients range from 0 to 255,
            thus with absolute distance a reasonable value for this threshold
            is between 200 and 300. With relative distance (ie ratio between
            distance to nearest and distance to second nearest), the commonly
            used value for the threshold is 0.6.

    Returns:
        a numpy array containing the list of matches

    It uses Ives' matching binary, from the IPOL http://www.ipol.im/pub/pre/82/
    """
    matchfile = tmpfile('.txt')
    run("matching %s %s %d %f 4 8 36 > %s" % (k1, k2, method, thresh, matchfile))
    matches = np.loadtxt(matchfile)
    # discard scale and orientation, then return
    return matches[:, [0, 1, 4, 5]]


def points_apply_homography(H, pts):
    """
    Applies an homography to a list of 2D points.

    Args:
        H: numpy array containing the 3x3 homography matrix
        pts: numpy array containing the list of 2D points, one per line

    Returns:
        a numpy array containing the list of transformed points, one per line
    """
    # if the list of points is not a numpy array, convert it
    if (type(pts) == list):
        pts = np.array(pts)

    # convert the input points to homogeneous coordinates
    if len(pts[0]) < 2:
        print """points_apply_homography: ERROR the input must be a numpy array
          of 2D points, one point per line"""
        return
    pts = np.hstack((pts[:, 0:2], pts[:, 0:1]*0+1))

    # apply the transformation
    Hpts = (np.dot(H, pts.T)).T

    # normalize the homogeneous result and trim the extra dimension
    Hpts = Hpts * (1.0 / np.tile( Hpts[:, 2], (3, 1)) ).T
    return Hpts[:, 0:2]


def bounding_box2D(pts):
    """
    bounding box for the points pts
    """
    dim = len(pts[0])      #should be 2
    bb_min = [ min([ t[i] for t in pts ]) for i in range(0, dim) ]
    bb_max = [ max([ t[i] for t in pts ]) for i in range(0, dim) ]
    x, y, w, h = bb_min[0], bb_min[1], bb_max[0]-bb_min[0], bb_max[1]-bb_min[1]
    return x, y, w, h


def image_crop_TIFF(im, x, y, w, h):
    """
    Crops tif images.

    Args:
        im: path to a tif image
        x, y, w, h: four integers definig the rectangular crop in the image.
            (x, y) is the top-left corner, and (w, h) are the dimensions of the
            rectangle.

    Returns:
        path to cropped tif image

    The crop is made with the gdal_translate binary, from gdal library. We
    tried to use tiffcrop but it fails.
    """
    if (int(x) != x or int(y) != y):
        print 'Warning: image_crop_TIFF will round the coordinates of your crop'

    out = tmpfile('.tif')

    try:
        with open(im, 'r'):
            # do the crop with gdal_translate, with option to remove any GDAL or GeoTIFF tag
            run('gdal_translate -co profile=baseline -srcwin %d %d %d %d %s %s' % (x,
                y, w, h, shellquote(im), shellquote(out)))

    except IOError:
        print """image_crop_TIFF: input image not found! Verify your paths to
                 Pleiades full images"""
        sys.exit()


def image_crop_LARGE(im, x, y, w, h):
    if (int(x) != x or int(y) != y):
        print 'Warning: image_crop_LARGE will round the coordinates of your crop'
    if im.lower().endswith('tif') or im.lower().endswith('tiff'):
       return image_crop_TIFF(im, x, y, w, h)
    else:
       print "image_crop_LARGE: the input image must be tif or tiff"
       return image_crop(im, x, y, w, h)


def image_pleiades_unsharpening_mtf():
    """
    Returns the filename (with path) of a precomputed unsharpening MTF fror
    sensor perfect pleiades images.

    This filter has been pre-computed for processing sensor perfect images
    resampled with a factor 1.4x. But in theory it should be adapted depending
    on the RESAMPLING_SPACING stored in the RPC xml files.
    """
    return '%s/../pleiades_data/idata_0009_MTF_89x89.tif'%(os.path.dirname(
                                                os.path.abspath(__file__)))


def run_binary_on_list_of_points(points, binary, option=None):
    """
    Runs a binary that reads its input on stdin.

    Args:
        points: numpy array containing all the input points, one per line
        binary: path to the binary. It is supposed to write one output value on
            stdout for each input point
        option: optional option to pass to the binary

    Returns:
        a numpy array containing all the output points, one per line.
    """
    # run the binary
    pts_file = tmpfile('.txt')
    np.savetxt(pts_file, points, '%.18f')
    p1 = subprocess.Popen(['cat', pts_file], stdout = subprocess.PIPE)
    if option:
        p2 = subprocess.Popen([binary, option], stdin = p1.stdout, stdout =
            subprocess.PIPE)
    else:
        p2 = subprocess.Popen([binary], stdin = p1.stdout, stdout =
            subprocess.PIPE)

    # recover output values: first point first, then loop over all the others
    line = p2.stdout.readline()
    out = np.array([[float(val) for val in line.split()]])
    for i in range(1, len(points)):
        line = p2.stdout.readline()
        l = [float(val) for val in line.split()]
        out = np.vstack((out, l))

    return out


def get_rectangle_coordinates(im):
    """
    Get the coordinates of a rectangle defined by the user's clicks.

    Args:
        im: path to an image to be displayed.

    Returns:
        x, y, w, h: coordinates of the rectangle selected by the user. x, y are the
            coordinates of the top-left corner, while (w, h) is the size of the
            rectangle.
    """
    points_file = tmpfile('.txt')
    current_dir = os.path.dirname(os.path.abspath(__file__))
    run('%s/viewGL.py %s > %s' % (current_dir, shellquote(im), points_file));
    (x1, y1, x2, y2) = map(int, open(points_file).read().split())
    # viewGL.py returns the coordinates of two corners defining the rectangle.
    # We can's make any assumption on the ordering of these coordinates.

    x = min(x1, x2)
    w = max(x1, x2) - x
    y = min(y1, y2)
    h = max(y1, y2) - y
    return x, y, w, h


def get_roi_coordinates(rpc, preview):
    """
    Get the coordinates of a desired ROI in a Pleiades image from user's clicks.

    Args:
        rpc: an instance of the rpc_model.RPCModel class, or the path to the
            xml file containing the RPC coefficients.
        preview: path to the preview image file associated to the Pleiades
            image.

    Returns:
        x, y, w, h: coordinates of the ROI selected by the user, in the
            Pleiades full image frame. x, y are the coordinates of the top-left
            corner, while (w, h) is the size of the rectangle.

    A preview image is displayed, on which the user selects a rectangular
    region.
    """

    # if 'rpc' is the path to a file, open it and read it, else go on
    try:
        with open(rpc):
            rpc = rpc_model.RPCModel(rpc)
    except TypeError:
        pass

    # read preview/full images dimensions
    nc = int(rpc.lastCol)
    nr = int(rpc.lastRow)
    nc_preview, nr_preview = image_size(preview)

    # get the rectangle coordinates
    x, y, w, h = get_rectangle_coordinates(preview)

    # rescale according to preview/full ratio
    x = int(x*nc/nc_preview)
    y = int(y*nr/nr_preview)
    w = int(w*nc/nc_preview)
    h = int(h*nr/nr_preview)
    return x, y, w, h
