import numpy as np
import os
import tempfile

# list of functions in this module:

# tmpfile
# run
# shellquote
#
# matrix_write
# matrix_read
# matrix_read_from_string
# matrix_translation
#
# bounding_box2D
# points_apply_homography
#
# image_crop_LARGE
# image_crop_TIFF
# image_apply_homography2
# image_apply_homography
# image_size
# image_crop
#
# image_sift_keypoints
# sift_keypoints_match
# image_qauto
#
# image_pleiades_unsharpening_mtf
# image_zeropadding_from_image_with_target_size
# image_fftconvolve

# global variable
# list of intermediary files generated by the script
garbage = list()

def tmpfile(ext=''):
    # TODO: fix this function
    # imout = os.tmpnam()+ext
    handler, imout = tempfile.mkstemp(suffix = ext)
    garbage.append(imout);
    return imout

def run(cmd):
    os.system("echo %s" % cmd)
    os.system(cmd)

def shellquote(s):
    return "'" + s.replace("'", "'\\''") + "'"

def matrix_write(filename , H12):
    f = open(filename,'w')
    f.write('[ %.20f  %.20f  %.20f ; '%(H12[0, 0], H12[0, 1], H12[0, 2]))
    f.write('  %.20f  %.20f  %.20f ; '%(H12[1, 0], H12[1, 1], H12[1, 2]))
    f.write('  %.20f  %.20f  %.20f ] '%(H12[2, 0], H12[2, 1], H12[2, 2]))
    f.close()

def matrix_read(fileName, rows=None, cols=None):
    return matrix_read_from_string(open(fileName).read(), rows, cols)

def matrix_read_from_string(line, rows=None, cols=None):
    x0 = []
    line = line.replace('[',' ')
    line = line.replace(']',' ')
    line = line.replace(',',' ')
    line = line.replace(';',' ')
    da = line.split()
    x0.append(map(float,da))
    #
    if(cols == None):
       x0 = np.array(x0)
    else:
       x0 = np.array(x0).reshape(rows, cols)
    #
    return(x0)

def matrix_translation(tx, ty):
    T = np.eye(3)
    T[0, 2] = tx;
    T[1, 2] = ty;
    return T

def image_size(im):
    out = tmpfile()
    run('imsize %s > %s' % (shellquote(im), out));
    (nc, nr) = map(int, open(out).read().split())
    return (nc, nr)

def image_crop(im, x, y, w, h, out=None):
    if (out == None):
        out = tmpfile()
    run('crop %s %s %d %d %d %d' % (im, out, x, y, w, h));
    return out

def image_fftconvolve(im, mtf):
    """
    returns the fourier convolution: F^{-1} ( F(im)  mtf )
    mtf and im must be the same size
    """
    out = tmpfile()
    run('fftconvolve %s %s %s' % (mtf, im, out))
    return out

def image_zeropadding_from_image_with_target_size(im, image_with_target_size):
    """
    zooms im by zero padding to the size of the image_with_target_size
    It works with the fft representation of im
    and just adds or remove frequencies from it
    No control of Gibbs artifacts
    """
    out = tmpfile()
    run('zoom_zeropadding %s %s %s' % (image_with_target_size, im, out))
    return out

def image_apply_homography2(out, im, H, w, h):
    """
    Applies an homography to an image.

    Args:
        out: path to the output image file
        im: path to the input image file
        H: numpy array containing the 3x3 homography matrix
        w, h: dimensions (width and height) of the output image

    Returns:
        nothing

    The output image is defined on the domain [0, w] x [0, h]. Its pixels
    intensities are defined by out(x) = im(H^{-1}(x)).
    """
    # if the input image dimensions are bigger than (w, h), then we just need
    # to call the homography binary, and crop the result to the desired size.
    # If not, request a bigger input image. This is due to the interface of the
    # homography binary we are using.
    in_w, in_h = image_size(im)
    if (w < in_w and h < in_h):
        im = image_apply_homography(im, H)
        image_crop(im, 0, 0, w, h, out)
        return
    else:
        print "image_apply_homography2: im dimensions must be bigger than (w, h)"
        return


def image_apply_homography(im, H):
    """
    Applies an homography to an image.

    Args:
        im: path to the input image file
        H: numpy array containing the 3x3 homography matrix

    Returns:
        path to the output image.

    It uses Pascal Monasse homography binary, which doesn't allow to specify
    the output image size. Output image has the same size as input.
    """
    # write the matrix to a file
    Hf = tmpfile('.txt')
    matrix_write(Hf, H)
    # apply the homography
    out = tmpfile('.tif')
    run("homography %s %s %s" % (im, Hf, out))
    return out


def image_qauto(im):
    """
    Uniform requantization between 0 and 255.

    Args:
        im: path to input image

    Returns:
        path of requantized image, saved as png
    """
    out = tmpfile('.png')
    run('qauto %s %s 2> /dev/null' % (im, out))
    return out


def image_sift_keypoints(I1, keyfile='', max_nb=None):
    if (keyfile == ''):
       keyfile = tmpfile('.txt')
    run("sift_keypoints %s %s" % (image_qauto(I1), keyfile))

    # remove header from keypoint files
    tmp = tmpfile('.txt')
    run("awk \'{if (NR!=1) {print}}\' %s > %s" % (keyfile, tmp))
    run("cp %s %s" % (tmp, keyfile))

    # keep only the first max_nb points
    if max_nb:
        run("head -n %d %s > %s" % (max_nb, keyfile, tmp))
        run("cp %s %s" % (tmp, keyfile))
    return keyfile

def sift_keypoints_match(k1, k2, thresh):
    """
    Find matches among two lists of sift keypoints.

    Args:
        k1, k2: paths to text files containing the lists of sift descriptors
        thresh: threshold for distance between SIFT descriptors. These
            descriptors are 128-vectors, whose coefficients range from 0 to 255,
            thus a reasonable value for this threshold is between 200 and 300.

    Returns:
        a numpy array containing the list of matches

    It uses Enric's siftu binary, with the nn distance
    """
    matchfile = tmpfile('.txt')
    run("siftu pair %f %s %s %s" % (thresh, k1, k2, matchfile))
    matches = np.loadtxt(matchfile)
    return matches


def points_apply_homography(H, pts):
    """
    Applies an homography to a list of 2D points.

    Args:
        H: numpy array containing the 3x3 homography matrix
        pts: numpy array containing the list of 2D points, one per line

    Returns:
        a numpy array containing the list of transformed points, one per line
    """
    import numpy as np
    # if the list of points is not a numpy array, convert it
    if (type(pts) == list):
        pts = np.array(pts)

    # convert the input points to homogeneous coordinates
    if len(pts[0]) < 2:
        print """points_apply_homography: ERROR the input must be a numpy array
          of 2D points, one point per line"""
        return
    pts = np.hstack((pts[:, 0:2], pts[:, 0:1]*0+1))

    # apply the transformation
    Hpts = (np.dot(H, pts.T)).T

    # normalize the homogeneous result and trim the extra dimension
    Hpts = Hpts * (1.0 / np.tile( Hpts[:, 2], (3, 1)) ).T
    return Hpts[:, 0:2]


def bounding_box2D(pts):
    """
    bounding box for the points pts
    """
    dim = len(pts[0])      #should be 2
    bb_min = [ min([ t[i] for t in pts ]) for i in range(0, dim) ]
    bb_max = [ max([ t[i] for t in pts ]) for i in range(0, dim) ]
    x, y, w, h = bb_min[0], bb_min[1], bb_max[0]-bb_min[0], bb_max[1]-bb_min[1]
    return x, y, w, h



def image_crop_TIFF(im, x, y, w, h):
    """
    Crops tif images.

    Args:
        im: path to a tif image
        x, y, w, h: four integers definig the rectangular crop in the image.
            (x, y) is the top-left corner, and (w, h) are the dimensions of the
            rectangle.

    Returns:
        path to cropped tif image

    The crop is made with the gdal_translate binary, from gdal library.
    """
    tmp = tmpfile('.tif')
    out = tmpfile('.tif')

    # do the crop with gdal_translate
    run('gdal_translate -srcwin %d %d %d %d %s %s' % (x, y, w, h,
                                      shellquote(im), shellquote(tmp)))
    # remove GeoTiff tags
    run('tiffcp %s %s 2> /dev/null' % (tmp, out))
    return out

    # Remark: with tiffcrop it fails:
    #    run('tiffcrop -U px -z %d,%d,%d,%d  %s  %s'%( x0,y0,x0+w,y0+h,
    #    shellquote(im),shellquote(imout)) )


def image_crop_LARGE(im, x, y, w, h):
    if im.lower().endswith('tif') or im.lower().endswith('tiff'):
       return image_crop_TIFF(im, x, y, w, h)
    else:
       print "image_crop_LARGE: the input image must be tif or tiff"


def image_pleiades_unsharpening_mtf():
    """
    Returns the filename (with path) of a precomputed unsharpening MTF fror
    sensor perfect pleiades images.

    This filter has been pre-computed for processing sensor perfect images
    resampled with a factor 1.4x. But in theory it should be adapted depending
    on the RESAMPLING_SPACING stored in the RPC xml files.
    """
    return '%s/../pleiades_data/idata_0009_MTF_89x89.tif'%(os.path.dirname(__file__))
    
